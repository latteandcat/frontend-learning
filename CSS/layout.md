# CSS布局

## 元素定位

### 标准流

默认情况下，元素都是按照**normal flow**进行排布的

- 从左到右、从上到下按顺序排放
- 默认情况下，互相之间不存在层叠现象
- 在标准流中可以使用margin、padding调整元素的位置
  - 缺点1：会影响到标准流中其他元素的位置
  - 缺点2：不便于实现元素的层叠效果

### position

position可以使元素跳出标准流单独定位

即允许从正常的文档流布局中取出元素，并使它们具有不同的行为

- 例如放在另一个元素的上面
- 或者保持在浏览器视窗内的同一位置

position的取值

- static：决定定位（默认值）

以下四个值可以让元素变为定位元素（positioned element）

- relative：相对定位
- absolute：绝对定位
- fixed：固定定位
- sticky：粘性定位

不同值之间的比较

![](../images/position.png)

### 相对定位

`position: relative;`

元素按照normal flow布局

并可以通过 left、right、top、bottom进行定位

定位的参照对象是**元素自身原来在标准流中的位置**

应用场景：在不影响其他元素的前提下，对当前元素位置进行微调

### 固定定位

`position: fixed;`

元素脱离normal flow布局

并可以通过left、right、top、bottom进行定位

定位的参照对象是**viewport**（文档的可视区域）

应用场景：当画布滚动时，当前元素固定不动

### 绝对定位

`position: absolute;`

元素脱离 normal flow 布局

并可以通过left、right、top、bottom进行定位

定位的参照对象是**最邻近的定位祖先元素**

如果找不到这样的祖先元素，参照对象就是viewport

> 子绝父相：
>
> 在大多数情况下，子元素的绝对定位都是相对于父元素进行定位，如果希望子元素相对于父元素进行定位，又不希望父元素脱离标准流，常常通过将父元素设置为相对定位子元素设置为绝对定位来实现

**绝对定位元素**：position值为absolute或fixed的元素

**绝对定位元素的特点**

- 可以随意设置宽高
- 宽高默认由内容决定
- 脱离标准流
- 不再给父元素汇报宽高（父元素的宽高不再考虑该元素）
- 内部还是标准流布局

**对于绝对定位元素来说**

- 定位参照对象的宽度 = left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度
- 定位参照对象的高度 = top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度

可以通过这个公式实现绝对定位元素在定位参照对象中的居中显示

- 将left、top、bottom、right设置为0
- 将margin设置为auto
- 设置绝对定位元素的具体宽高

### 粘性定位

`position: sticky;`

粘性定位可以看作相对定位和固定定位的结合体

- 在滚动到某个阈值点之前为相对定位
- 达到阈值点之后变成固定定位

sticky是相对于最近的祖先滚动容器的滚动视口（the nearest ancestor scroll container's scrollport)

### z-index

z-index属性用于设置定位元素的层叠顺序

- 仅对定位元素有效
- 取值可以是正整数、负整数、0

z-index的比较原则

- 如果是兄弟关系
  - z-index越大，层叠在越上面
  - z-index相等，写在后面的那个元素层叠在上面
- 如果不是兄弟关系
  - 各自从元素自己以及祖先元素中找出最邻近的两个定位元素进行比较
  - 而且这两个定位元素必须有设置z-index的具体数值

## 元素浮动

### float

float属性可以指定一个元素沿其容器的左侧或右侧放置，允许文本和内联元素环绕它

- float最初只用在一段文本内浮动图像，实现文字环绕的效果

- 但是早期的的CSS标准中并没有提供好的左右布局方案，因此在一段时间里面它成为网页多列布局的最常用工具
- 绝对定位和浮动都会让元素脱离标准流，已达到灵活布局的效果

float可以让元素产生浮动效果

- none： 不浮动，默认值
- left：向左浮动
- right：向右浮动

### 浮动规则

1. 元素浮动后会脱离标准流

   - 朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止

   - 定位元素会层叠在浮动元素上面

2. 如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界
3. 浮动元素之间不能层叠
   - 如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素
   - 如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止

4. 浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出

   比如：行内级元素、inline-block元素、块级元素的文字内容

5. 行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐

> 换行符会导致行内级元素、inline-block元素之间出现水平间隙
>
> 解决方法：
>
> 1. 删除换行符
> 2. 将父级元素的font-size设置为0，但是需要子元素设置回来
> 3. 通过子元素统一像一个方向浮动即可
> 4. flex布局

### 高度塌陷

由于浮动元素会脱离标准流，父元素计算总高度的时候，不会计算浮动子元素的高度，这会导致父元素的**高度塌陷**问题

解决父元素高度塌陷问题的过程，一般叫做**清除浮动**

清楚浮动的目的是让父元素计算总高度的时候，把浮动子元素的高度算进去

清楚浮动的方法：

- 给父元素设置固定高度

  缺点：扩展性不好

- 在父元素最后增加一个空的块级子元素，并且设置clear属性为both

  缺点：会增加很多无意义的空标签，违反结构与样式分离的原则

  > clear 属性可以指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面
  >
  > - left：要求元素的顶部低于之前生成的所有左浮动元素的底部
  > - right：要求元素的顶部低于之前生成的所有右浮动元素的底部
  > - both：要求元素的顶部低于之前生成的所有浮动元素的底部
  > - none：默认值，无特殊要求

- 给父元素添加一个伪元素

  ```css
  .clear-fix::after {
    content: "";
    display: block;
    clear: both;
    visibility: hidden; /* 浏览器兼容性 */
    height: 0; /* 浏览器兼容性 */
  }
  .clear-fix {
    *zoom: 1; /* IE6/7兼容性 */
  }
  ```
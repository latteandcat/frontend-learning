# 深入浏览器渲染原理

## 网页解析流程

1. 在浏览器输入网页的 URL

2. 浏览器通过 DNS 将 URL 解析为服务器的 IP 地址

3. 然后向服务器请求静态资源

   一般情况下是先请求 html 文件

   遇到 link 元素再请求 css 文件

   遇到 script 元素再请求 js 文件

4. 服务器返回静态资源给浏览器

5. 浏览器对静态资源进行解析和展示

## 浏览器渲染流程

### 浏览器内核

浏览器内核指的是浏览器的排版引擎（浏览器引擎、页面渲染引擎或样板引擎）

浏览器内核负责解析网页语法，并渲染网页，常见的浏览器内核有

- Trident（三叉戟）：IE、360安全、搜狗、百度、UC；
- Gecko（壁虎 ）：Firefox
- Presto → Blink：Opera
- Webkit：Safari、360极速、搜狗、移动端浏览器
- Webkit → Blink（眨眼）：Google Chrome、Edge

浏览器内核由两部分组成，以 Webkit 为例

- WebCore：负责 HTML 解析、布局、渲染等等相关的工作
- JavaScriptCore：解析、执行JavaScript代码

### 一般流程

<img src="../images/browser-rendering-flow.JPG" style="zoom: 33%;" />

### 详细流程

[How browsers work (web.dev)](https://web.dev/howbrowserswork/)

<img src="../images/webkit-main-flow.png" style="zoom: 67%;" />

1. 解析 HTML，构建 DOM Tree

2. 生成 CSS 样式规则

   - 在 HTML 解析的过程中，如果遇到 CSS 的 link 元素，浏览器就会下载对应的 CSS 文件

     下载 CSS 文件不会影响 DOM 的解析

   - 浏览器下载完 CSS 文件后，就会对 CSS文件 进行解析，解析出对应的规则树（CSSOM Tree）

3. 构建 Render Tree

   当有了 DOM Tree 和 CSSOM Tree 后，就可以结合起来构建 Render Tree 了

   - link 元素不会阻塞 DOM Tree 的构建过程，但是会阻塞 Render Tree 的构建过程

     因为 Render Tree 在构建时，需要对应的 CSSOM Tree

   - Render Tree 和 DOM Tree 并不是一一对应的关系

     比如对于 display 为 none 的元素，并不会出现在 Render Tree 中

4. 布局

   布局就是在 Render Tree 上运行布局（Layout）以计算每个节点的几何体

   可以理解为确定节点的大小和位置

   - Render Tree 会表示显示哪些节点以及节点的其他样式，但是不表示每个节点的尺寸、位置等信息
   - 布局是确定呈现树中所有节点的宽度、高度和位置信息

5. 绘制

   将每个节点绘制（Paint）到屏幕上

   - 在绘制阶段，浏览器将布局阶段计算的每个 frame 转为屏幕上实际的像素点
   - 绘制的内容包含元素的可见部分，比如文本、颜色、边框、阴影、替换元素

### 回流和重绘

**回流 reflow**

- 第一次确定节点的大小和位置叫做布局
- 之后对节点的大小、位置的修改和重新计算叫做回流

- 回流的触发情况

  - DOM 结构发生改变（添加或移除节点）

  - 改变了元素布局（修改了 width、height、padding、font-size）

  - 窗口的 resize （修改了窗口的尺寸）

  - 调用 getComputedStyle 获取尺寸和位置

**重绘 repaint**

- 第一次渲染内容叫做绘制 paint
- 之后的重新渲染称之为重绘

- 重绘的触发情况
  - 修改背景色
  - 修改文字颜色
  - 修改边框颜色
  - 修改样式
  - 等等

**回流一定会引起重绘**，所以回流非常消耗性能，在开发中要尽量避免发生回流

**避免发生回流的注意事项**

1. 修改样式时尽量一次性修改

   比如通过 cssText 修改，比如通过添加 class 修改

2. 尽量避免频繁的操作 DOM

   我们可以在一个 DocumentFragment 或者父元素中将要操作的 DOM 操作完成

   再一次性地操作

3. 尽量避免通过 getComputedStyle 获取尺寸、位置等信息

4. 对某些元素使用 position 的 absolute 或者 fixed

   并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响

### 合成

绘制的过程中可以将布局后的元素绘制到多个合成图层中

- 默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的

- 一些特殊的属性，会创建一个新的合成层（ Compositing Layer ）

  并且新的图层可以利用GPU来加速绘制

- 每个合成层都是单独渲染的

- 合成是浏览器优化渲染的一种手段

可以形成新的合成层的常见属性

- 3D transforms
- video、canvas、iframe 元素
- `opacity` 动画转换时
- `position: fixed`
- `will-change` 一个实验性属性，提前告诉浏览器元素可能发生哪些变化 
-  animation 或 transition 设置了opacity、transform

分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用 

## script 元素

**script 元素与页面解析的关系**

1. 浏览器在解析 HTML 的过程中，遇到了 script 元素或者外联 js 文件会停止构建 DOM 树
2. 先下载 JavaScript 代码，并且执行 JavaScript 的脚本
3. 等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树

为什么要这样做

- 这是因为 JavaScript 的作用之一就是操作 DOM，并且可以修改 DOM
- 如果我们等到 DOM 树构建完成并且渲染再执行 JavaScript，会造成严重的回流和重绘，影响页面的性能
- 所以会在遇到 script 元素时，优先下载和执行 JavaScript 代码，再继续构建 DOM 树

但是现代开发模式中 JS 代码的处理时间往往很长，有可能会造成页面的解析阻塞

即在脚本下载和执行完成之前，用户在界面上什么都看不到

**script 的 defer 和 async 属性可以用于解决这个问题**

此外，对于这种被阻塞的情况，浏览器也可能会通过优化将 DOM Tree 中已经构建的部分提前渲染出来以提升用户体验

### defer

 defer 属性告诉浏览器不要等待脚本下载，而继续解析 HTML，构建 DOM Tree

- 脚本会由浏览器来进行下载，但是不会阻塞 DOM Tree 的构建过程

  如果脚本提前下载好了，它会等待 DOM Tree 构建完成，先执行 defer 中的代码

  然后触发 DOMContentLoaded 事件

- 多个带 defer 的脚本是可以保持正确的顺序执行的

- 从某种角度来说，defer 可以提高页面的性能，并且推荐放到 head 元素中

- defer 仅适用于外部脚本，对于 script 默认内容会被忽略

### async

async 与 defer 类似也可以让脚本不阻塞页面

async 可以让脚本完全独立地下载并执行

- 浏览器不会因 async 脚本而阻塞
- async 脚本不能保证顺序，它是独立下载、独立运行的，不会等待其他脚本
- async 不会能保证在 DOMContentLoaded 之前或者之后执行

> 应用场景
>
> defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，适用于对多个 script 文件有顺序要求的情况
>
> async 通常用于独立的脚本，适用于对其他脚本甚至 DOM 没有依赖的情况

### 对比

正常情况下遇到 JS 脚本

1. 停止构建 DOM Tree
2. 下载并执行 JS 脚本
3. 继续构建 DOM Tree
4. DOM Tree 构建完成触发 DOMContentLoaded 事件

defer 情况下遇到 JS 脚本

1. 下载 JS 脚本但不停止构建 DOM Tree
2. 构建完成才能够开始执行 JS 脚本
3. 多个 defer 脚本在下载完成后会顺序执行
4. 全部执行完毕后触发 DOMContentLoaded 事件

async 情况下遇到 JS 脚本

1. 独立下载和执行 JS 脚本
2. 不阻塞 DOM Tree 的构建
3. DOM Tree 构建完成触发 DOMContentLoaded 事件

# 深入 JS 运行原理

## V8 引擎介绍

V8 引擎是一个强大 JavaScript 引擎

- V8 是用 C++ 编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎

  它用于 Chrome 和 Node.js 等

- V8 实现了 ECMAScript 和 WebAssembly，可以在多个平台运行

- V8 可以独立运行，也可以嵌入到任何 C++ 应用程序中

![](../images/V8.png)

## V8 引擎的执行原理

 V8  引擎的架构

- [Parse 模块](https://v8.dev/blog/scanner)：用于将 JavaScript 代码转换成 AST（抽象语法树）
  - 因为解释器并不直接认识 JavaScript 代码
  - 如果函数没有被调用，那么是不会被转换成 AST 的

- [Ignition 解释器](https://v8.dev/blog/ignition-interpreter)：将 AST 转换成 ByteCode（字节码）
  - 同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）
  - 如果函数只调用一次，Ignition 会解释执行 ByteCode

- [Turbofan 编译器](https://v8.dev/blog/turbofan-jit)：将字节码编译为 CPU 可以直接执行的机器码
  - 如果一个函数被多次调用，那么就会被标记为热点函数
  
    热点函数会经过 TurboFan 转换成**优化的机器码**，提高代码的执行性能
  
  - 但是，机器码实际上也会被还原为 ByteCode
  
    因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码

V8 引擎的解析图

![](../images/V8-detail.png)

Scanner 扫描器即为词法分析器 lexical analyzer

- 词法分析 lexical analysis 就是将字符序列转换成 token 序列的过程
- token 就是记号化 tokenization

Parser 即为语法分析器 syntactic analyzer

- 语法分析 syntactic analysis 也叫 Parsing
- 语法分析就是将对应的 tokens 分析成 AST 的过程

> V8引擎执行原理总结
>
> 1. Scanner -> 词法分析：将字符序列转换成 token 序列
>
> 2. Parser -> 语法分析：将对应的 token 序列分析成抽象语法树 AST
>
> 3. Ignition -> 代码解释：将抽象语法树 AST 转换成字节码 ByteCode
>
> 4. Turbofan -> 代码编译：将字节码编译为 CPU 可以直接执行的机器码
>
>    热点函数会被 Turbofan 转换为优化的机器码
>
>    如果热点函数在执行过程中发生变化导致优化的机器码不可用，优化的机器码也会逆向转换为字节码

## JS 代码执行原理

版本说明

- 大部分流行说法或者面试内容都是 ECMAScript3 的版本内容
- 但 ECMAScript5 和 ECMAScript6 以及更好的版本内容也有理解的必要

学习顺序

- 通过 ECMAScript3 中的概念学习 JS 执行原理、作用域、作用域链、闭包等概念
- 通过 ECMAScript6 中的概念学习块级作用域、let、const 等概念

> **JS 代码的执行流程**
>
> 1. 执行代码之前，会在堆内存中创建一个全局对象 GO
>
> 2. 构建全局执行上下文 GEC，关联 GO 并放入执行上下文栈 ECS
>
> 3. 将全局定义的变量和函数声明添加到 GO 中，但并不赋值（也叫做变量的作用域提升）
>
> 4. 执行代码，对变量赋值或者执行其他函数
>
> 5. 每执行到一个函数就根据函数体创建一个函数执行上下文 FEC 放入 ECS
>    - 先创建一个 AO 对象关联到 FEC
>    
>      AO 在初始化时会包含 arguments 对象，并且初始值是传入的参数
>    
>    - 然后将函数形参以及函数中定义的变量和函数声明添加到 AO 中
>    
>    - 最后执行代码，对变量赋值或执行其他函数
>    
> 6. 栈顶的 EC 执行完就会出栈，然后继续执行栈顶的 EC
>
> 此外每个执行上下文中还关联了一个作用域链和一个 this 对象

### 执行上下文

代码在执行的时候会创建一个执行上下文

JS 引擎内部有一个执行上下文栈 Execution Context Stack（ECS），它是用于执行代码的调用栈

- 活跃的执行上下文逻辑上会形成一个栈
- 栈顶的执行上下文就是正在运行的执行上下文

每一个执行上下文会关联一个变量对象 Variable Object（VO），变量和函数声明会被添加到 VO 中

### 全局执行上下文

全局代码在执行的时候创建的执行上下文叫做全局执行上下文 Globla Execution Context（GEC）

GEC 也会被放入到 ECS 中执行，GEC 的 VO 就是全局对象 GO

JS 引擎会在执行代码（进入执行上下文）之前，在堆内存中创建一个全局对象 Global Object（GO）

- GO 在所有作用域中都可以访问
- GO 中包含 Date、Array、String、Number、setTimeout、setInterval 等等
- GO 中还有一个 window 属性指向自己

GEC 在 ECS 中的执行包含两部分

- 第一部分：在代码执行前，在 Parser 将 JS 代码转换为 AST 的过程中，会将全局定义的变量、函数等加入到 GO 中，但是并不会赋值，这个过程就叫做变量的作用域提升
- 第二部分：执行代码，对变量赋值或者执行其他的函数

### 函数执行上下文

在执行的过程中执行到一个函数时

就会根据函数体创建一个函数执行上下文 Functional Execution Context（FEC）

FEC 也会被放入到 ECS 中执行

当进入一个函数执行上下文时，会创建一个 Activation Object（AO）

- AO 在初始化时会包含 arguments 对象，并且初始值是传入的参数

- AO 会作为 FEC 的 VO 用于变量的初始化

  即在执行代码前将函数形参、函数内部的变量和函数声明添加到 AO 中

- 最后执行代码，对变量赋值或者执行其他的函数

重复执行函数的时候，每次都会创建新的 AO 放入 ECS，执行后再出栈

当函数中调用了另一个函数的时候，执行到调用的代码时会进入一个新的 FEC，执行结束将新的 FEC 出栈，然后继续执行调用这个函数的 FEC

### 作用域链

**作用域**表示变量标识符的有效作用范围

**作用域链**是一个对象列表，用于变量标识符的求值

- 当进入到一个执行上下文时，执行上下文会创建并关联一个作用域链 Scope Chain

  并且根据代码类型，添加一系列的对象

- 全局执行上下文的作用域链里只有一个 GO

- 在查找变量的值时，执行上下文会首先在自身的 VO 中查找

  如果没有则沿着作用域链去上层作用域的 VO 中查找

  直到查找到全局执行上下文中的 GO

- 函数在定义的时候就确定了自己的作用域链

  所以函数中变量的取值与函数的调用没有关系，而与函数的定义位置有关

## JS 内存管理

### 内存管理概念

任何编程语言都需要对内存进行管理，有些语言是手动的，有些语言是自动的

==内存管理的一般生命周期==

1. 分配内存：分配申请需要的内存
2. 使用内存：使用分配的内存
3. 释放内存：不需要使用时对分配的内存进行释放

内存的分配和释放有两种实现方式

- 手动管理内存：比如 C 和 C++
- 自动管理内存：Java、JavaScript、Python、Swift、Dart

 ### JS 的内存分配

JS 会在定义数据时为其分配内存

- 对于原始数据类型，内存的分配会在执行时，直接在栈空间中进行分配
- 对于复杂数据类型，内存的分配会在堆空间中开辟一块空间，并且将这块空间的指针（内存地址）返回给变量引用

### JS 的垃圾回收

因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间

在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如 free 函数

但是手动管理内存有一定的缺陷

1. 手动管理的效率较低，也会影响我们编写代码的效率
2. 对开发者的要求也很高，并且一不小心就会产生内存泄露

所以大部分现代编程语言都有自己的垃圾回收机制

**垃圾回收机制**

垃圾回收机制 Garbage Collection 简称 GC

- 对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间

- 而我们的语言运行环境

  比如 Java 的运行环境 JVM，JavaScript的运行环境 JS 引擎中

  都包含内存的垃圾回收器 GC

- GC 是通过垃圾回收算法确定哪些对象是需要回收的

**垃圾回收算法**

1. 引用计数（Reference counting）

   - 当一个对象有一个引用指向它时，那么这个对象的引用就 +1

   - 当一个对象的引用为 0 时，这个对象就可以被销毁掉

   - 弊端是会产生循环引用

2. 标记清除（Mark sweep）

   - 标记清除的核心思路是可达性（Reachability）
   - 标记清除就是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象
   - 标记清除可以解决循环引用问题          

3. JS 引擎采用比较广泛的就是标记清除算法，V8 引擎在实现时为了优化也会结合一些其他算法  

   - 标记整理（Mark Compact）

     与标记清除相似，但在回收的同时会将保留的对象汇集到连续的内存空间

     从而整合空闲空间，避免内存碎片化

     标记整理 = 标记清除 + 空闲空间整理

   - 分代收集（Generational collection）

     将对象分成新旧两组，新的对象检查的频次比旧的对象的检查频次更高

     新创建的对象可能很快被清理，而长期存活的对象被清理的概率比新对象小，检查频次就可以相应的减少

   - 增量收集（Incremental collection）

     如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟；

   - 闲时收集（Idle-time collection）
   
     垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

### V8 的内存划分

![](../images/V8-GC.png)

## 闭包

### 闭包的定义

闭包在计算机科学中的定义

- 闭包（Closure），又称词法闭包（Lexical Closure）或函数闭包（Function Closure）
- 闭包是在支持**头等函数**的编程语言中，实现词法绑定的一种技术
- 闭包在实现上是一个**结构体**，它存储了**一个函数**和**一个关联的环境**（相当于一个符号查找表）
- 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行

闭包在 JS 中的定义

- 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）

  这样的组合就是闭包（closure）

- 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域

- 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来

总结： 如果一个普通的函数可以访问外层作用域的自由变量，那么这个函数和其周围环境就组成了一个闭包

- 从广义的角度来说：JavaScript 中的函数都是闭包
- 从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用域的自由变量，那么它是一个闭包

### 闭包的内存泄露

```js
function createAdder(count) {
    function adder(num) {
        return count + num
    }
    return adder
}

var adder5 = createAdder(5)
adder5(10)
adder5(20)
```

正常情况下 createAdder 函数执行完毕它对应的 AO 会被释放

但是因为 adder5 通过作用域链找到并引用了这个 AO

所以 createAdder 执行时创建的 AO 并不会被释放

并且由于 全局变量 adder5 引用了 createAdder(5) 创建的函数对象

当这个函数对象不再被使用时，这个函数对象和引用的外部作用域的AO 也不会被释放

这种情况下就出现了内存泄漏，其实 adder5 的作用域链中引用的所有对象都是无法释放的

简单的讲就是 adder5 一直可达，导致 adder5 作用域链上的对象也一直可达

adder5 不再使用之后，这些对象的内存就发生了泄漏

如何解决这个问题

1. `adder5 = null` 先释放不再使用的函数对象的引用，那么对应的作用域链中的对象就会不再可达
2. 在 GC  的下一次检测中，它们就会被垃圾回收器销毁

其次，浏览器会对内存泄漏的情况进行优化，将 AO 中其他没有被使用的变量释放掉

比如 createAdder 的 AO 中有一些没有被 adder 用到的变量，浏览器会将它们释放掉，只保留 count

> **闭包**：如果一个函数访问了其外层作用域的自由变量，它就是一个闭包，这个闭包由这个函数和其外部环境组成
>
> **闭包的内存泄露**：如果闭包内的函数的引用始终存在，则这个函数对象和其引用的作用域链中的对象就无法释放，始终在堆内存中存在
>
> **内存泄漏的解决办法**：将闭包内函数的引用在使用后置为 null，这个函数对象和其引用的作用域链中的对象就会被 GC 自动回收
